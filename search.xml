<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NOIP2012借教室]]></title>
    <url>%2F2017%2F07%2F16%2FNOIP2012%E5%80%9F%E6%95%99%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[NOIP2012 借教室 题目描述洛谷传送门 在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj, sj, tj ，表示某租借者需要从第sj 天到第tj 天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 输入 输入文件为 classroom.in。 第一行包含两个正整数n, m，表示天数和订单的数量。 第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。 接下来有m行，每行包含三个正整数dj, sj, tj ，表示租借的数量，租借开始、结束分别在第几天。 每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。 样例输入 4 32 5 4 32 1 33 2 44 2 4 样例输出 -12 说明 【输入输出样例说明】 第 1 份订单满足后，4 天剩余的教室数分别为 0，3，2，3。 第 2 份订单要求第 2 天到第 4 天每天提供 3 个教室，而第 3 天剩余的教室数为 2，因此无法满足。 分配停止，通知第2 个申请人修改订单。 【数据范围】 对于10%的数据，有1≤ n,m≤ 10；对于30%的数据，有1≤ n,m≤1000；对于 70%的数据，有1 ≤ n,m ≤ 10^5；对于 100%的数据，有1 ≤ n,m ≤ 10^6,0 ≤ ri,dj≤ 10^9,1 ≤ sj≤ tj≤ n。 题解 输入后暴力地修改区间直到该日教室数为负数？（然而只有40 于是二分加上差分修改区间即可 如何查分修改区间？比如一开始数列a是0 0 0 0 0 0前缀和0 0 0 0 0 03到5天需要2的教室将a[3]+=2,a[6]-=2数列变为0 0 2 0 0 -2前缀和变为0 0 2 2 2 0这样就实现了增加3-5需要的教室数简单粗暴不是吗？ 怎样二分？二分查找第一个为负数的订单输出即可 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1005000;int n,m,l,r,ans,sum,a[maxn],ss[maxn];struct bill&#123; int d,s,t;&#125;b[maxn];bool judge(int v)&#123; memset(ss,0,sizeof(ss));sum=0; for(int i=1;i&lt;=v;i++)&#123; ss[b[i].s]+=b[i].d;ss[b[i].t+1]-=b[i].d; &#125; for(int i=1;i&lt;=n;i++)&#123; sum+=ss[i]; if(sum&gt;a[i]) return 0; &#125; return 1;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;b[i].d,&amp;b[i].s,&amp;b[i].t); &#125; int l=1,r=m; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(!judge(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(!ans) printf(&quot;0\n&quot;); else printf(&quot;-1\n%d\n&quot;,ans); getchar();getchar();getchar();getchar();getchar(); return 0;&#125;]]></content>
      <categories>
        <category>NIOP</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到徐博恒的博客 0v0第一篇博客，测试一下功能。 Title 标题Sub title 子标题Sub title 子子标题]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>