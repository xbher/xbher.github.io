<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces-853/A]]></title>
    <url>%2F2017%2F09%2F07%2FCodeforces-853-A%2F</url>
    <content type="text"><![CDATA[Codeforces 853/A Planning 题目描述Codeforces Helen works in Metropolis airport. She is responsible for creating a departure schedule. There are n flights that must depart today, the i-th of them is planned to depart at the i-th minute of the day. Metropolis airport is the main transport hub of Metropolia, so it is difficult to keep the schedule intact. This is exactly the case today: because of technical issues, no flights were able to depart during the first k minutes of the day, so now the new departure schedule must be created. All n scheduled flights must now depart at different minutes between (k+1)-th and (k+n)-th, inclusive. However, it’s not mandatory for the flights to depart in the same order they were initially scheduled to do so — their order in the new schedule can be different. There is only one restriction: no flight is allowed to depart earlier than it was supposed to depart in the initial schedule. Helen knows that each minute of delay of the i-th flight costs airport ci burles. Help her find the order for flights to depart in the new schedule that minimizes the total cost for the airport. 输入 The first line contains two integers n and k (1≤k≤n≤300000), here n is the number of flights, and k is the number of minutes in the beginning of the day that the flights did not depart. The second line contains n integers c1,c2,…,cn (1≤ci≤107), here ci is the cost of delaying the i-th flight for one minute. 输出 The first line must contain the minimum possible total cost of delaying the flights. The second line must contain n different integers t1,t2,…,tn (k+1≤ti≤k+n), here ti is the minute when the i-th flight must depart. If there are several optimal schedules, print any of them. 样例输入 5 24 2 1 10 2 样例输出 203 6 7 4 5 说明 【输入输出样例说明】Let us consider sample test. If Helen just moves all flights 2 minutes later preserving the order, the total cost of delaying the flights would be (3-1)·4+(4-2)·2+(5-3)·1+(6-4)·10+(7-5)·2=38 burles. However, the better schedule is shown in the sample answer, its cost is (3-1)·4+(6-2)·2+(7-3)·1+(4-4)·10+(5-5)·2=20 burles. 题解 其实这是一个水题，保证维护费最大的航班先飞，用优先队列贪心即可。 PS:注意花费要用long long,不然会炸 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=300500;int n,k;long long cost;struct flight&#123; int c,pos; bool operator &lt;(const flight&amp;a)const&#123; return a.c&gt;c; &#125;&#125;f[maxn];int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)&#123; f[i].pos=i; scanf("%d",&amp;f[i].c); &#125; priority_queue &lt;flight&gt; q; for(int i=1;i&lt;=k;i++) q.push(f[i]); for(int i=k+1;i&lt;=n+k;i++)&#123; if(i&lt;=n) q.push(f[i]); flight now=q.top();q.pop(); cost+=(long long)(i-now.pos)*now.c; f[now.pos].pos=i; &#125; printf("%lld\n",cost); for(int i=1;i&lt;=n;i++) printf("%d ",f[i].pos); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015信息传递]]></title>
    <url>%2F2017%2F08%2F08%2FNOIP2015%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[NOIP2015 信息传递 题目描述洛谷传送门 有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti同学。 游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？ 输入 输入文件名为 message.in。 输入共2行。 第1行包含1个正整数n，表示n个人。 第2行包含n个用空格隔开的正整数T1,T2,…,Tn，其中第i个整数Ti表示编号为i的同学的信息传递对象是编号为Ti的同学，Ti&lt;=n且Ti≠i。 数据保证游戏一定会结束 输出 输出文件名为 message.out。 输出共1行，包含1个整数，表示游戏一共可以进行多少轮。 样例输入 52 4 2 3 1 样例输出 3 说明 【输入输出样例说明】 游戏的流程如图所示。 当进行完第 3 轮游戏后， 4 号玩家会听到 2 号玩家告诉他自己的生日，所以答案为 3。 当然，第 3 轮游戏后， 2 号玩家、 3 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。 【数据范围】 对于 30%的数据， n ≤ 200；对于 60%的数据， n ≤ 2500；对于 100%的数据， n ≤ 200000。 题解 题意为找最小环 分析题意易得输入的图为环及其枝叶且不存在两个环在同一个联通块内的情况，于是bfs剪去枝叶，然后dfs出每个环的节点数并取最小值即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;using namespace std;const int maxn=233333;int n,cur,ans=1&lt;&lt;30,out[maxn],vis[maxn];int dfs(int x)&#123; if(vis[x]) return cur; vis[x]=1;cur++; int next=out[x];out[x]=0; dfs(next);&#125;void cutting()&#123; queue &lt;int&gt; q; for(int i=1;i&lt;=n;i++) if(!vis[i]) q.push(i); while(!q.empty())&#123; int x=q.front();q.pop(); int next=out[x];out[x]=0;vis[next]--; if(!vis[next]) q.push(next); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;out[i]); vis[out[i]]++; &#125; cutting(); for(int i=1;i&lt;=n;i++) if(out[i])&#123; cur=0;memset(vis,0,sizeof(vis)); ans=min(ans,dfs(i)); &#125; printf("%d\n",ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012借教室]]></title>
    <url>%2F2017%2F07%2F16%2FNOIP2012%E5%80%9F%E6%95%99%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[NOIP2012 借教室 题目描述洛谷传送门 在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj, sj, tj ，表示某租借者需要从第sj 天到第tj 天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 输入 输入文件为 classroom.in。 第一行包含两个正整数n, m，表示天数和订单的数量。 第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。 接下来有m行，每行包含三个正整数dj, sj, tj ，表示租借的数量，租借开始、结束分别在第几天。 每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。 输出 输出文件为 classroom.out。 如果所有订单均可满足，则输出只有一行，包含一个整数 0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。 样例输入 4 32 5 4 32 1 33 2 44 2 4 样例输出 -12 说明 【输入输出样例说明】 第 1 份订单满足后，4 天剩余的教室数分别为 0，3，2，3。 第 2 份订单要求第 2 天到第 4 天每天提供 3 个教室，而第 3 天剩余的教室数为 2，因此无法满足。 分配停止，通知第2 个申请人修改订单。 【数据范围】 对于10%的数据，有1≤ n,m≤ 10；对于30%的数据，有1≤ n,m≤1000；对于 70%的数据，有1 ≤ n,m ≤ 10^5；对于 100%的数据，有1 ≤ n,m ≤ 10^6,0 ≤ ri,dj≤ 10^9,1 ≤ sj≤ tj≤ n。 题解 输入后暴力地修改区间直到该日教室数为负数？（然而只有40 于是二分加上差分修改区间即可 如何查分修改区间？比如一开始数列a是0 0 0 0 0 0前缀和0 0 0 0 0 03到5天需要2的教室将a[3]+=2,a[6]-=2数列变为0 0 2 0 0 -2前缀和变为0 0 2 2 2 0这样就实现了增加3-5需要的教室数简单粗暴不是吗？ 怎样二分？二分查找第一个为负数的订单输出即可 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1005000;int n,m,l,r,ans,sum,a[maxn],ss[maxn];struct bill&#123; int d,s,t;&#125;b[maxn];bool judge(int v)&#123; memset(ss,0,sizeof(ss));sum=0; for(int i=1;i&lt;=v;i++)&#123; ss[b[i].s]+=b[i].d;ss[b[i].t+1]-=b[i].d; &#125; for(int i=1;i&lt;=n;i++)&#123; sum+=ss[i]; if(sum&gt;a[i]) return 0; &#125; return 1;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;b[i].d,&amp;b[i].s,&amp;b[i].t); &#125; int l=1,r=m; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(!judge(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; if(!ans) printf("0\n"); else printf("-1\n%d\n",ans); getchar();getchar();getchar();getchar();getchar(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到徐博恒的博客 0v0第一篇博客，测试一下功能。 Title 标题Sub title 子标题Sub title 子子标题]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
